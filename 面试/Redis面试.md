### Redis处理流程

![img](https://img-blog.csdn.net/20180919143214712?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd0aWFvNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### Redis持久化机制

- RDB：按照一定的时间周期策略把内存中的数据以快照的形式保存到硬盘。
- AOF：将收到的每一条命令都通过write函数追加到文件最后，当Redis重启时，重新执行文件中保存的写命令来在内存中重构整个数据库内容

当两种同时开启时，Redis会优先选择AOF

### Redis可能遇到的问题

- 缓存穿透

  ​	缓存穿透使之缓存和数据库中都没有的数据，而用户不断发起请求，如发起id为-1/id特别大不存在的数据，这时的用户很有可能是攻击者，攻击会导致数据库压力过大。

  ​	解决方法：

  1. 接口增加校验，如用户鉴权校验，id做基础校验，id <= 0 直接拦截。

   	2. 缓存和数据库中都没有的数据，可以将key-valu写为key-null,缓存有效时间可以设置短点，如30s，可以防止攻击用户反复用同一个id暴力攻击。
   	3. 布隆过滤器：将所有可能存到的数据Hash到一个足够大的bitmap中，一个一定不存在的数据会被bitmap拦截掉，避免了对底层存储系统的查询压力。

- 缓存击穿

  ​	 缓存中没有，但是数据库中有的数据（一般是缓存时间到期），由于并发用户特别多，同时读缓存没读到数据，由同时去数据库读，导致数据压力瞬间增大在，造成过大压力。

  ​	解决方案：设置热点数据永不过期；加互斥锁。

- 缓存雪崩

  ​	缓存层出现了错误,不能正常工作/缓存中数据大批量到达过期时间,于是所有的请求都会到达存储层，存储层调用量暴增，造成存储层宕机。

  ​	**缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到，从而查数据库**

  ​	解决方法：

   	1. Redis高可用：多加几台Redis，即搭建集群
   	2. 限流降级：在缓存失效后，通过加锁或队列控制读数据库写缓存的线程数量，比如对一个key只允许一个线程查询数据和写缓存
   	3. 数据预热：先把可能的数据预访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生高并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效时间尽量均匀。

- 缓存更新

  ​	除了缓存服务器自带的缓存失效策略之外（Redis默认有6种策略），还可以根据具体业务进行自定义的缓存淘汰

   	1. 定时清理过期缓存，维护大量缓存的key比较麻烦。
   	2. 当用户请求发过来时，判断对应的缓存是否过期，过期就去底层得到新数据并更新缓存。每次请求都要判断是否失效，逻辑相对复杂。

### Memcache和Redis区别

1. Redis支持持久化
2. Memcache所有的值都是简单的字符串，redis支持五种数据类型
3. 使用底层模型不同，Redis自己构建了VM机制。
4. Value值大小不同，Redis最大可以达到512M，Memcache只有1MB
5. Redis速度比Memcache快很多
6. Redis支持数据备份

### Redis为什么这么快

1. 纯内存操作
2. 单线程操作，避免了频繁上下文操作
3. 采用了非阻塞I/O多路复用机制

### Redis数据类型

 1. String

    value可以是String也可以是数字，一般是做一些复杂的计数功能的缓存。

	2. hash存放的是结构化的对象

    存放的是结构化的对象，方便操作其中某个字段。单点登录时，用hash存储用户信息，cookieId作为key，设置30min为过期时间

	3. list

    简单的消息队列，可以使用lrange做基于redis的分页，性能极佳，用户体验好。

	4. set

    因为set存放的是一堆不重复值的集合，可以做到全局去重。

	5. sorted set

    相比set多了一个权值参数score，集合中的元素可以按score进行排列，可以做排行榜。

### Redis为什么是单线程的

因为Redis是基于内存的操作，CPU不是瓶颈，瓶颈最有可能是机器内存大小或网络带宽。既然单线程容易实现，并且CPU不是瓶颈，那就采取单线程，毕竟采用多线程会有很多麻烦。

### Redis集群方案

1. twemproxy
2. codis
3. redis cluster 3.0

### 多机Redis部署，如何保证数据一致性

主从复制，读写分离

一类是主数据库（master），一类是从数据库（slave），主数据库可以读写，从数据库只支持度，当发生写操作的时候会自动将数据从主数据库复制到从数据库。一个主数据库可以有多个从数据库，一个从数据库只能有一个主数据库。

### Redis常见性能问题和解决方案

1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
2. 如果数据比较重要，某个slave开启AOF备份数据，策略设置为每秒同步一次。
3. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图庄结构，用单向链表更加稳定，即薪火相传：master > slave1 > slave2 > slave3

### 为什么Redis的操作是原子性的，怎么保证原子性

原子性的定义：一个操作不可再分，操作要么执行，要么不执行

Redis原子性是因为它是单线程的。

Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。

### Redis事务

Redis事务通过MULTI，EXEC，DISCARD和WATCH四个原语实现。

Redis会将一个事务中所有命令序列化，然后顺序执行

1. Redis不支持回滚，“Redis”在事务失败时不进行回滚，而是继续执行余下的命令
2. 如果一个事务的命令出现错误，所有的命令都不会执行
3. 如果一个事务出现运行错误，那么正确的命令会被执行

- MULTI命令用于开启一个事务，总是返回OK，MULTI执行后，客户端可以继续向服务器发送任意多个命令，不会立即执行而是别放在队列中，当exec命令被调用时，队列中的才会执行。
- EXEC：执行所有事物块中的命令，返回事务块中所有命令的返回值，按命令执行的先后顺序排列，当被打断时，返回控制nil
- DISCARD：清空事务，放弃执行事务，并从事务状态退出。
- WATCH：可以为Redis事务提供check-and-set（CAS）行为，可以监控一个或者多个键，当有一个键被修改或者删除，之后的事务就不会执行。



