> 2021年7月22日21:05:10

### redis用什么实现点赞功能?

set

### Redis如何实现分页查询功能

使用sortedSet，使用id作为score

### 跳表

最底层是原始链表，每两个结点建立第一级索引，再对一级索引链表建立二级索引。

这个索引的结构是val，next，forward，next 指向同层索引的下一个结点，forward指向下一层索引的结点。时间复杂度是o(logn)，空间复杂度是o(n);

**为什么不用红黑树？**

红黑树键查找效率不如跳表高

跳表的实现相对更简单

跳表更灵活

**跳表插入元素**

首先根据跳表找到要插入的位置，执行插入操作，可以通过重建索引表的方式，但是这样每次插入数据的时间复杂度就是o(n)，还有就是可以随机选出n/2个数当一级索引，然后随机n / 4个数当二级索引，当然也会有极端情况，每次随机出的都是链表的前n/ 2个元素，但是这种情况太低了，同时，redis是为了应付大数据量的情况，因此随机出前n/ 2的概率更低。可以通过概率算法算出应该插到几级索引中，然后维护索引并将数据插到链表中。随机概率是1到max_value

**跳表删除元素**

首先查找要删除的元素，然后执行删除，删除元素时间复杂度为o(1)，索引logn层最多删除logn个元素，删除元素总时间等于查找元素时间+ 删除logn元素时间 = o(logn) + o(logn) = 2o(logn) = log(n);

> 2021年7月23日10:18:47

### 读写分离如何保证数据一致性

可以采用全同步模式，只有当所有从库都复制完成主库才向客户端返回结果，或者说通过程序控制，将强一致性的功能读写均使用主库。弱一致性的话可以将一些时间较久的数据静态化，或者干脆点，提示用户操作成功，请等待30秒后刷新重试。

### 多服务器情况下，如何保证session共享

1. 可以采用nginx轮询，根据ip计算出一个数，将这个数对服务器的台数取余，计算应该到哪个服务器
2. Redis保存sessionid，使用springsession框架

### 消息队列作用

异步处理，应用解耦，流量控制  



> 2021年7月25日14:55:42

### TCP UDP

#### TCP

通过检验和，序列号，确认应答，重发控制，连接管理以及窗口控制来保证可靠性。

重发超时的超时时间是通过每次计算往返时间及其偏差得到的，Unix和windows超时都以0.5秒为单位控制，重发超时时间都是0.5的整数倍，最初超时时间设置为6秒。 重发时如果还收不到确认应答，就会再次发送，这时等待确认的时间将会以2倍、4倍指数函数式延长。到达一定次数，就会认为网络或目标主机发生了异常，强制关闭连接。

TCP三次握手时，确定最大消息长度（MSS，Maximum Segment Size）。

滑动窗口：确认应答不是以每个分段，而是以更大的单位进行确认，转发时间将大幅缩小。通过使用缓冲区，对多个段同时进行确认应答实现。缓冲区即窗口内的数据即使没有收到确认应答也可以发出，在确认应答返回前，需要在缓冲区保留数据，收到确认应答后，窗口将滑到确认应答中的序列号位置。这个时候，如果某些确认应答即使丢失后，也不需要重发， 可以根据下一个确认应答进行确认。如果发送的数据包丢失，那么接收端会不断向发送端发送某个序号的确认应答，如果发送端连续收到3次听一个确认应答，就会将数据重发。



流量控制：是指在发送数据的时候，接收端会给发送端发送一个自己可以接收数据的大小，也就是窗口大小，当接收端发现自己的缓冲区满的时候，会给发送端发送一个末尾为0的数据，表示窗口目前只能接受0个数据。如果在重发超时时间以后还没有收到窗口更新通知，发送端就会发送一个窗口探测包；如果接收端处理完了，那么就会给发送端发送一个窗口更新包，如果窗口更新丢失，发送端会时不时发送窗口探包。为了防止数据发送过去了，但是接收方来不及接收的情况，根本目的是为了防止分组丢失。

拥塞控制：作用于网络，防止过多的数据注入到网络，避免出现网络负载过大的情况，常用的方法是慢开始，拥塞避免，快重传，快恢复。它维护一个拥塞窗口，叫cwnd，大小取决于网络的拥堵情况。**慢开始**意思是一开始不发送大量的数据，先探测一下网络拥塞情况，从小到大增加cwnd。发送方每接到一个ack，就将CWND加一，如果全部接受，下一次发送的CWND的大小就是上一次发送的两倍。为了防止过大,需要设置一个阈值。cwnd < 阈值，使用慢开始，大于阈值，使用拥塞避免，等于阈值，慢开始和拥塞避免都可以。**拥塞避免**是到达阈值时，TCP是每经过一个往返时间，就将CWND加一，而不是翻倍，这个称为**加法增大**。如果发现网络出现拥堵，就把阈值设置为出现拥塞时的一半，这个称为**乘法减小**，然后再采用慢开始从1开始计算CWND 的值。**快重传** 意思是接收方收到一个失序的包就重复发送确认，发送方只要连续收到三个来自同一个包的确认请求，就立即重传对方未收到的报文。**快恢复** ： 当收到连续的三个包确认时，并不意味着出现了网络拥塞，将CWND减半赋值给阈值，然后从阈值开始执行加一操作。

#### UDP

UDP是不具有可靠性的数据报协议。即使网络拥堵，UDP无法进行流量控制。即使出现丢包情况，UDP也不负责重发。到达的包顺序乱掉时，也没有纠正功能。



TCP UDP通过5个信息来识别一个通信：源IP，目标IP，协议号，源端口，目标端口

#### TCP UDP 区别

TCP是面向**连接**的，UDP无连接，发送数据之前不需要建立连接

TCP提供**可靠**服务，通过TCP传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，不保证可靠交付。

TCP面向**字节流**，UDP面向报文。UDP没有拥塞控制，因此网络出现拥堵不会降低主机的发送速率。

TCP只能是**点对点**，UDP支持一对一，一对多，多对一，多对多交互。

TCP**首部**20字节，UDP首部8字节

TCP的**逻辑通信信道**是全双工的可靠信道，UDP是不可靠信道



#### 端口号确认：

标准既定的端口号：每个应用程序都有其指定的端口号

时序分配法：这个需要确定监听端口号，但是接受服务的客户端没必要确定，可以交给操作系统分配，操作系统可以在之前分配的号码上加一。

> 2021年7月26日09:39:56

### 插入一条数据？一个字段的流程

编译器解析

优化器根据采样和统计涉及字段的cardinality确定走索引还是全盘扫描

写undolog，记录版本和回滚指针

如果不是唯一索引，记录到change buffer等待刷入磁盘，否则从磁盘读入内存校验是否存在

执行器拿到，行版本 + 1，写入redolog

执行器生成binlog，commit->提交prepare阶段redo刷盘，commit阶段binlog刷盘



因为是插入操作，事务结束后可以删除undolog，否则更新和删除的话需要放在待清理列表判断是否上一个版本还有事务在使用。



### static 修饰类，方法，变量有什么用

static 只能修饰内部类，static修饰的内部类相当于一个普通的类，通过new 外部类名.内部类访问。作用是如果需要一个内部类，需要先通过new一个外部类，然后再通过外部类实例创建内部类。

static 修饰的方法访问方式是类名.静态方法名。避免了new出对象的繁琐和资源消耗。

static修饰的变量为静态变量，静态变量在内存中只有一份内存空间，静态变量不属于某个实例对象，它属于类。方便数据共享给所有对象使用。

#### Mysql 主从复制的时候是主服务器推还是从服务器拉？

在一开始进行同步的时候，从服务器会将自己的file 和offset 告知主服务器，然后master在本地binlog查找，将剩余的binlog发送给slave，这个是pull；

当master有新的binlog产生，它会广播通知dump thread ，dump thread 读取binlog主动发送给slave，这个是push。



#### == 和equals的区别

8种基本数据类型用== 比较，比较的是值。

引用数据类型用==比较的是堆内存地址。

equals 默认情况下比较的也是地址值，但是可以根据情况重写方法。

### G1收集器

G1是面向服务端应用的垃圾收集器，特点是**并行与并发，分代收集，空间整合和可预测的停顿。**

它将Java的整个堆分成多个大小相等的独立区域（region）。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小和回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。但是这样存在一个问题就是一个对象可能会被其他region的对象所引用。虚拟机通过一个remembered set，当发现程序对引用数据类型进行写操作是，会生成一个write barrier暂停写操作，查看引用的对象是否在不同region，如果是，通过cardtable把相关的引用信息记录到remembered set，进行垃圾回收时，根据remembered set 就可以不用全堆扫描也能保证无遗漏。

###### G1收集器的步骤

初始标记 标记GCroot 能直接关联到的对象。 STW

并发标记 从gcroot开始对堆中对象进行可达性分析，标记出存活的对象

最终标记 为了修正在并发标记期间用户程序继续运作而导致标记发生变化的对象。 STW

筛选回收 对各个region的回收价值和成本排序，根据用户期望的GC停顿时间来指定回收计划。

####  GCroot对象

1. 虚拟机栈中引用的对象
2. 方法区静态属性引用的对象
3. 方法区常量引用的对象
4. 本地方法栈引用的对象

### 七层网络模型

应用层 ： HTTP FTP SMTP

会话层 ：SMTP DNS

传输层 ：TCP UDP

网络层 ： IP



#### static 修饰的变量存在哪儿

JDK7及以后版本的HotPost虚拟机，选择把静态变量与Class对象放一起，存储与堆中





> 2021年7月27日09:00:32

## 双亲委派

#### 什么是双亲委派

当一个类加载器收到了类加载的请求时，他不会直接去加载这个类，而是把请求委托给自己的父类加载器去加载。只有父类加载器无法加载的时候，才会由当前类加载器去加载

#### 四种类加载器职责

Bootstrap： 加载java核心类库，lib下的rt.jar， resource.jar， charset.jar

Extension 负责加载目录 lib/ext目录下的jar和class文件

Application ：加载当前应用classpath下的类

User ClassLoader:  用户自定义类加载器，可以加载指定路径的class文件。

#### 为什么要双亲委派

1. 避免类的重复加载
2. 保证了安全

#### 如何主动破坏双亲委派

自定义类加载器，重写loadclass方法。

#### JDBC 为什么要破坏双亲委派

因为连接时用到的DriverManager是rt.jar， 会被根加载器加载。类加载时，会执行类的静态方法，ServiceLoader.load会尝试加载classpath下所有实现了Driver接口的实现类。实现类是第三方的，不能由根加载器加载。引入了ThreadContextClassLoader线程上下文加载器。

#### Spring Aop 四种实现方式

1. 基于代理AOP
2. @AspectJ注解驱动的切面
3. 纯pojo切面
4. 注入式AspectJ切面

#### List和Set 区别

list可以存放重复的元素。set不行

list能保证插入的顺序，set不行

list可以通过下标访问，set 不行

#### 反射是什么？什么时候使用反射？

反射是指在运行期间可以动态生成对象，执行对象的方法，改变对象的属性。

SpringAop动态代理使用反射

JDBC 数据库连接用反射。

#### 线程安全的HashMap

HashTable

Collections.SynchronizeMap

ConcurrentHashMap

### 排序算法

| 排序方法 | 平均时间复杂度 | 最坏  | 最好  | 空间复杂度 | 稳定性 |
| -------- | -------------- | ----- | ----- | ---------- | ------ |
| 插入     | n2             | n2    | n     | 1          | 稳定   |
| 冒泡     | n2             | n2    | n     | 1          | 稳定   |
| 选择     | n2             | n2    | n2    | 1          | 不     |
| 快速     | nlogn          | n2    | nlogn | nlogn      | 不     |
| 希尔     | n1.3           | n2    | n     | 1          | 不     |
| 归并     | nlogn          | nlogn | nlogn | n          | 稳定   |
| 堆排序   | nlogn          | nlogn | nlogn | 1          | 不     |

 

### HTTPS的CA证书放了什么

公钥、签名和有效期

### 检测死锁的工具

1. jstack -l pid
2. jconsole
3. jvisualVm

### 线程状态详细说明

初始状态： new出来一个线程类，就进入初始状态

就绪状态：调用start方法进入就绪状态；时间片用完调用yield进入就绪状态；锁池的线程拿到对象锁，进入就绪状态

运行状态：线程调度程序从可运行池中选择一个线程作为当前线程所处的状态。

等待：CPU不会分配执行时间片，需要等待显示唤醒

超时等待：在一定时间后自动唤醒

结束：线程的run方法完成，或者主线程的main方法完成后。

### 银行家算法

每个进程都有需要的，已分配的，还需要的的数量。当有一个进程请求资源时，操作系统首先判断当前的可用资源是不是小于等于进程需要的资源，如果小于进程所需要的资源，那么就认为系统属于不安全状态，让这个进程继续等待。

如果大于等于请求的进程所需要的资源，那么就判断剩余的资源能不能让其他线程中的一个结束，结束后以便回收资源增加可用资源，将这个进程标记为已完成状态，继续试探其他进程，如果所有进程都可以获取到资源，那么就表示系统处于安全状态。



### 死信队列

是一种消息机制，当消费消息时，如果有以下情况之一，消息将设置为死信

1. 被channel.basicNack或者channel.reject， 并且requeue设置为false
2. 消息在队列存活时间超过设置的TTL值
3. 消息队列的消息数量超过最大长度

如果rabbitmq配置了死信队列消息，就会把死信放在死信队列，否则消息将被丢弃





> 2021年7月28日20:24:40

### 幂等性解决方案

唯一索引: 防止脏数据 **插入**

token机制：生成一个token保存到redis中，然后发送给客户端，提交的时候携带token，收到提交后删除token 

乐观锁: 加上版本号 **更新**

 下游传递唯一序列号 ： **插入更新删除** 需要设置过期时间

select + insert ：可以先查询之前是否插入成功

### AQS

1. 调用tryAcquire() 尝试直接去获取资源，如果成功直接返回

2. 没成功, 则addwaiter() 将线程加入等待队列尾部，并标记为独占模式
3. acquireQueued()使线程在等待队列中休息，有机会时尝试获取资源，获取到资源才返回，如果在等待中被中断，则返回true，否则返回false。
4. 如果线程在等待过程中被中断，它不响应，只有才获取资源后才进行自我中断，将中断补上。



> 2021年7月29日08:56:20

### CAP

1. consistency一致性

   写操作之后的读操作，必须返回该值。可以通过向另一台机器发送消息，使之更新数据。

2. availability可用性

   只要收到用户请求，服务器必须回应。

3. partition tolerance 分区容错

   两个跨区服务器之间的通信可能丢失。一般来说 分区容错无法避免，可以假设P总是成立的。

   

一致性和可用性的矛盾：

如果要求一致性，那么必定需要锁表，在锁表期间无法实现可用性。

如果要求可用性，那么必然不能锁表，无法实现一致性。

### @RequestMapping 和  @GetMapping

GetMapping 是一个组合注解，是@RequestMapping(Method = RequestMethod.Get的缩写)



### 分布式Id常见生成策略

1. 数据库自增id
2. UUID
3. Redis原子资政
4. 批量申请自增id
5. 百度UidGenerator
6. 美团Leaf算法
7. 雪花算法

### 雪花算法

使用64bit的long型数字作为唯一Id，引入了时间戳，保持自增且不重复

第一个比特不用，默认是0

41比特时间戳 单位是毫秒

10比特工作机器id，最多可以部署到2^10=1024台机器上

12bit序列号 也就是一毫秒内最多生成4096个id。



 如果需要生成唯一id，那么就发送请求给部署了雪花算法的系统，让这个系统生成唯一id，

每秒能生成26万id。

### mybatis #{} 和${}区别

#将所有传入数据都当成字符串，$传入的是实际的值

#能防止SQL注入，$不能



### mysql查询交集并集差集

交集 inner join

并集 union union all

差集 left join

### Redis主从复制

配置： 从服务器配置文件设置salveof ip port

断开： slaveof no one

首先建立连接，保存主节点信息，然后建立socket连接，每秒调用复制定时函数，然后根据主节点ip和port建立连接，从节点建立一个文件事件处理器，负责后续复制工作，主节点将从节点看作是连接从节点的客户端。然后发送ping命令，返回pong，表示正常，未返回则断开重连，返回pong以外的结果，表示无法处理命令，断开重连。如果有身份认证，就进行身份认证。身份验证完成后，从节点发送其监听的端口号，主节点保存端口号。

**数据同步阶段。** 从节点向主节点发送psync命令开始同步。

**命令传播阶段。** 主节点将自己执行的命令发送给从节点，从节点收到后执行。在发送命令时，还维持着心跳机制。



复制分为全量复制和部分复制。

**全量复制**：首先执行bgsave，生成rdb文件，生成缓冲区，记录从现在开始的所有命令，然后将rdb文件发给从服务器，从服务器执行，然后主服务器发送缓冲区命令，从执行。

**部分复制：**

### HashMap 死锁

在扩容的时候发生死锁，第一个线程将元素按照头插法插入后，还没把新的扩容后的table赋值给新的table，时间片用完了，然后第二个线程发现该扩容了，然后再采用头插法，这个时候就会发生死锁。





