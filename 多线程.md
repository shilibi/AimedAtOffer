## volatile

用volatile 关键字修饰的变量在写操作的时候会多一行lock代码， Lock前缀执行在多核下会发生两件事：1、将当前处理器缓存行的数据写到系统内存 2、写操作会使其他CPU缓存了该内存地址的数据无效。这个使用到了缓存一致性协议（MESI）。



## 锁的升级

#### 无锁

无锁是指一个共享变量被多个线程修改，但同时只有一个线程能修改成功。线程会不断尝试修改值，如果修改成功，就退出；如果修改失败，就不断尝试。

#### 偏向锁

**升级：**同步代码一直被一个线程访问，这个线程就会自动获取锁。

经研究发现，锁不仅不存在竞争，而且一把锁经常被同一个线程获取，因此一个线程获取到对象锁的时候，会在对象头和栈帧标记当前线程id，以后该线程进入退出同步块不需要CAS加锁解锁，只需要判断对象头是否存储当前线程的偏向锁id。如果成功，说明获取到锁，如果失败，判断MarkWord偏向锁标识位是否为1，如果为1，尝试使用CAS将对象头的偏向锁指向当前线程，如果不为1，使用CAS竞争锁。

**锁的撤销** 偏向锁使用等到竞争出现才释放锁的机制，当其他线程竞争偏向锁时，持有偏向锁的线程才会释放锁。等到全局安全点时，暂停拥有偏向锁的线程，判断拥有所对象的线程是否存活，如果不存活，则将对象设置为无锁，<font  color=red>如果存活，拥有偏向锁的栈会执行，栈中的锁记录和markword要么重新偏向其他线程，要么恢复无锁或标记对象不适合作为偏向锁，最后唤醒所有暂停的线程。</font >

#### 轻量级锁

**前提：** 锁对象不能带有偏向特征。

**升级：** 当锁是偏向锁时，被另外的线程访问，就会由偏向升级为轻量。其他线程会通过自旋尝试获取锁，不会阻塞。

**加锁** 线程执行同步块之前，JVM先在当前线程栈帧创建存储锁记录空间，将对象头的MarkWord复制到锁记录中，然后线程尝试使用CAS将对象头的Markword替换为指向锁记录的指针，成功，获得锁，失败，表示其他线程竞争到锁，当前线程则自旋。

**解锁** 使用CAS操作将Displaced Mark Word 替换回对象头，如果成功，表示没有竞争发生；失败，表示存在竞争，锁膨胀为重量级锁再解锁。

#### 重量级锁

自旋超过一定次数或者一个线程在持有锁，一个在自选，又有第三个来访，轻量级升级为重量级。

## CAS问题：

### ABA 

JDK1.5开始，Atomic包里提供了一个类AtomicStampedReference

### 循环时间长开销大

如果JVM能支持处理器提供的pause，效率会有一定的提高

### 只能保证一个共享变量原子操作

可以用锁或者将多个共享变量合并为一个共享变量。JDK1.5开始，提供AtomicReference类保证引用对象之间的原子性



























1、创建线程的方式

2、为什么sleep 是Thread 中的方法，wait 是Object的方法(2个) 

等待和唤醒必须是同一把锁，又因为synchronized能锁任何对象，所以将可以被任何对象调用的方法写在object里